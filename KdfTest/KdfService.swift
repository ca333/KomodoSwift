import Foundation
import Combine
#if canImport(UIKit)
import UIKit
#endif
#if canImport(UserNotifications)
import UserNotifications
#endif

/// A service that manages the lifecycle of the Komodo DeFi Framework (KDF)
/// instance.  It starts mm2 with a custom configuration, polls the local
/// JSON‑RPC endpoint for the version string every 10 seconds, and exposes
/// the latest version via the `@Published` property `version`.
@MainActor
final class KdfService: ObservableObject {
    /// The current version string returned from the `version` RPC method.  It
    /// becomes available once the RPC server is up.  If `nil`, the version
    /// has not yet been fetched or the fetch failed.
    @Published var version: String?

    /// The number of times the version has been fetched.  Incremented
    /// whenever `fetchVersion()` completes, whether triggered manually
    /// or by the periodic timer.
    @Published var fetchCount: Int = 0

    /// Accumulated mm2 log output.  Lines are appended as mm2 emits log
    /// messages.  You can display this in the UI to observe internal
    /// events and troubleshooting information.
    @Published var logs: String = ""

    /// Accumulated log messages from the client application itself.
    /// Use this to trace API calls and actions performed by the
    /// KdfService.  Unlike `logs`, which contains mm2 output, this
    /// collects messages generated by the Swift code.
    @Published var appLogs: String = ""

    /// Indicates whether the mm2 RPC interface is currently reachable.  This
    /// is set to `true` when a version fetch succeeds and `false` if
    /// fetching fails or mm2 appears to be down.  The UI can bind to
    /// this to show a green/red indicator.
    @Published var rpcUp: Bool = false

    /// Countdown in seconds until the next automatic version fetch.  This
    /// value resets to the fetch interval (10 seconds) each time a
    /// fetch completes and decrements every second.  The UI can use
    /// this to display a live countdown.
    @Published var secondsUntilNextFetch: Int = 0

    /// Indicates whether a version fetch is currently in progress.  Use
    /// this to show a spinner in the UI while waiting for a response.
    @Published var isFetching: Bool = false

    /// The current fetch interval in seconds.  This is 10 seconds in the
    /// foreground and 60 seconds in the background.  Changing this
    /// value via `updateFetchInterval` will reschedule the version
    /// (and balance) timer accordingly.
    private var currentInterval: Double = 10.0

    // MARK: - KMD coin state

    /// Whether the KMD coin is currently enabled.  Set to `true` after
    /// a successful `enable` RPC call and `false` after `disable_coin`.
    @Published var isKmdEnabled: Bool = false

    /// The most recently fetched KMD balance.  This is updated after
    /// a successful `my_balance` call and shown in the UI.  The value
    /// is stored as a string to preserve precision (mm2 returns
    /// decimal strings for coin balances).
    @Published var kmdBalance: String?

    /// The address associated with the KMD coin as reported by the
    /// `my_balance` RPC.  This is nil until `fetchKmdBalance()`
    /// retrieves it.
    @Published var kmdAddress: String?

    /// Timer used to periodically fetch the version.  Stored here so it can
    /// be invalidated when the service stops.
    private var timer: Timer?

    /// A secondary timer used to update the `secondsUntilNextFetch`
    /// countdown once per second.  Invalidated in `stop()`.
    private var countdownTimer: Timer?

    /// A static reference to the currently running `KdfService` instance.
    /// This is used by the C log callback to forward log messages back
    /// into Swift.  When `start()` is called this is set to `self`, and
    /// cleared when `stop()` is called.  Without this indirection, the
    /// `@convention(c)` callback cannot capture `self` directly.
    private static weak var currentInstance: KdfService?

    /// A flag indicating whether mm2 has been started to avoid starting
    /// multiple times.
    private var started = false

    /// A flag indicating whether the notification permission has been requested.
    private var notificationPermissionRequested: Bool = false

#if canImport(UIKit)
    /// Identifier for the background task used to keep timers running
    /// when the application is in the background.  This is only
    /// available on iOS and will be `UIBackgroundTaskIdentifier.invalid` on
    /// other platforms.
    #if canImport(UIKit)
    private var backgroundTask: UIBackgroundTaskIdentifier = .invalid
    #endif
#endif

    /// Start mm2 with the predefined configuration.  This method computes
    /// a suitable `dbdir` for iOS, converts the configuration to JSON, and
    /// invokes `mm2_main`.  Once the RPC server is ready, it schedules a
    /// recurring timer to fetch the version every 10 seconds.
    func start() {
        guard !started else { return }
        started = true

        // Assign the static instance pointer so the C log callback can
        // forward log messages.  It is safe to do this only on start
        // because at most one mm2 instance is running at a time.
        KdfService.currentInstance = self

        // Determine the application support directory and append a `kdf` subfolder.
        let homeURL: URL
        if let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
            homeURL = appSupport
        } else if let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
            // Fallback to documents directory if application support is unavailable.
            homeURL = documents
        } else {
            // As a last resort use the temporary directory.
            homeURL = FileManager.default.temporaryDirectory
        }
        let dbDirURL = homeURL.appendingPathComponent("kdf", isDirectory: true)
        do {
            try FileManager.default.createDirectory(at: dbDirURL, withIntermediateDirectories: true)
        } catch {
            print("[KdfService] Failed to create db directory at \(dbDirURL.path): \(error)")
        }

        // Build the configuration dictionary.  Note that `mm2` must be set
        // to `1` to enable the native mm2 mode.  `passphrase` is the seed
        // phrase used to derive wallet keys.  See the question prompt for
        // details on each field.
        // Define at least one coin configuration.  The Komodo (KMD) coin is
        // provided here as an example.  Additional coins can be appended to
        // this array following the same structure.  Without a non‑empty
        // `coins` array mm2 will fail to start with an error like
        // "invalid type: null, expected a sequence".
        let coinsList: [[String: Any]] = [
            [
                "coin": "KMD",
                "name": "komodo",
                "fname": "Komodo",
                "rpcport": 7771,
                "pubtype": 60,
                "p2shtype": 85,
                "wiftype": 188,
                "txversion": 4,
                "overwintered": 1,
                "txfee": 1000,
                "mm2": 1,
                "sign_message_prefix": "Komodo Signed Message:\n",
                "required_confirmations": 2,
                "requires_notarization": true,
                "avg_blocktime": 60,
                "protocol": ["type": "UTXO"],
                "derivation_path": "m/44'/141'",
                "trezor_coin": "Komodo",
                "links": [
                    "github": "https://github.com/komodoplatform/komodo",
                    "homepage": "https://komodoplatform.com"
                ]
            ]
        ]

        var config: [String: Any] = [
            "mm2": 1,
            "allow_weak_password": true,
            "rpc_password": "use_safe_password",
            "netid": 8762,
            "gui": "DEVIN_AGENT",
            "passphrase": "echo brick chimney lazy flush silver mail sea finish fiber basket chef",
            "enable_hd": false,
            "seednodes": ["seed01.kmdefi.net", "seed02.kmdefi.net"],
            "i_am_seed": false,
            "dbdir": dbDirURL.path
        ]
        // Write the coins list to a JSON file in the db directory and also
        // provide the inline definition.  mm2 can load coins from either
        // a file path or a directly embedded list.  Writing the file
        // aids debugging and future extension, but we still set the
        // inline `coins` field to ensure the coin definitions are
        // always available.  If writing fails the inline list will
        // suffice.
        do {
            let coinsFileURL = dbDirURL.appendingPathComponent("coins.json")
            let coinsData = try JSONSerialization.data(withJSONObject: coinsList, options: [.prettyPrinted])
            try coinsData.write(to: coinsFileURL)
        } catch {
            print("[KdfService] Failed to write coins file: \(error)")
        }
        // Provide the inline definition for mm2 to read.  This avoids
        // "No such coin" errors that occur when mm2 fails to read the
        // file.
        config["coins"] = coinsList

        // Request notification permission once when starting mm2.  The user
        // will be prompted the first time the service starts if they have
        // not already granted permission.  Only request on iOS platforms.
        #if canImport(UserNotifications)
        if !notificationPermissionRequested {
            notificationPermissionRequested = true
            UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) { granted, error in
                if let error = error {
                    print("[KdfService] Notification permission error: \(error)")
                }
                if granted {
                    print("[KdfService] Notification permission granted")
                } else {
                    print("[KdfService] Notification permission denied")
                }
            }
        }
        #endif

        // Serialize the configuration to JSON.
        let confData: Data
        do {
            confData = try JSONSerialization.data(withJSONObject: config, options: [])
        } catch {
            print("[KdfService] Failed to serialize config to JSON: \(error)")
            return
        }
        guard let confString = String(data: confData, encoding: .utf8) else {
            print("[KdfService] Failed to convert config JSON to String")
            return
        }

        // Define a C log callback that forwards log messages to the console.
        // The callback reads log lines from mm2 and dispatches them to
        // `appendLog` on the current KdfService instance.  It cannot
        // capture `self` directly because it uses the C calling
        // convention, so we use the static `currentInstance` property.
        let logCallback: @convention(c) (UnsafePointer<Int8>?) -> Void = { cString in
            guard let ptr = cString else { return }
            let message = String(cString: ptr)
            // Print to the console for debugging purposes
            print("[mm2] \(message)")
            // Append to the service logs on the main queue
            DispatchQueue.main.async {
                KdfService.currentInstance?.appendLog(message)
            }
        }

        // Start mm2 on a background thread so that it does not block the UI.
        DispatchQueue.global(qos: .default).async {
            confString.withCString { confPtr in
                let result = mm2_main(confPtr, logCallback)
                if result != 0 {
                    print("[KdfService] mm2_main returned error code \(result)")
                }
            }
        }

        // Poll mm2_main_status until the RPC server is up.  Once the status
        // equals 3 (RPC is up) schedule the version timer.  To avoid a busy
        // wait on the main thread, polling is done asynchronously.
        DispatchQueue.global(qos: .default).async { [weak self] in
            var attempts = 0
            while attempts < 40 { // up to ~20 seconds (40 × 0.5s)
                let status = mm2_main_status()
                if status == 3 {
                    DispatchQueue.main.async {
                        if let strongSelf = self {
                            strongSelf.scheduleVersionTimer(withInterval: strongSelf.currentInterval)
                            // Mark RPC as up once mm2 reports ready
                            strongSelf.rpcUp = true
                            // Countdown is handled in scheduleVersionTimer
                        }
                    }
                    return
                }
                attempts += 1
                Thread.sleep(forTimeInterval: 0.5)
            }
            print("[KdfService] mm2_main_status never reached RPC up state")
        }
    }

    /// Stop mm2 and invalidate the timer.  It is good practice to stop
    /// mm2 when the app goes into the background or is terminated.
    func stop() {
        timer?.invalidate()
        timer = nil
        let result = mm2_stop()
        if result != 0 {
            print("[KdfService] mm2_stop returned error code \(result)")
        }
        started = false
        // When stopped, mark RPC as down
        rpcUp = false

        // Invalidate the countdown timer and reset the countdown
        countdownTimer?.invalidate()
        countdownTimer = nil
        secondsUntilNextFetch = 0

        // Cancel any active background task
        endBackgroundTask()

        // Clear the static instance pointer so that log messages are no
        // longer delivered after stopping.
        KdfService.currentInstance = nil
    }

    /// Schedule a repeating timer that fetches the KDF version every
    /// 10 seconds.  The timer is invalidated and recreated each time this
    /// method is called to avoid multiple active timers.
    /// Schedule or reschedule the repeating timer that fetches the KDF
    /// version (and KMD balance when enabled) at the given interval.
    /// The timer is invalidated and recreated whenever this method is
    /// called.  The countdown timer is also reset to the provided
    /// interval.  The timer triggers an immediate fetch upon
    /// scheduling.
    private func scheduleVersionTimer(withInterval interval: Double) {
        timer?.invalidate()
        // Ensure no stale countdown timer is running
        countdownTimer?.invalidate()
        // Immediately perform a fetch when scheduling
        Task { [weak self] in
            guard let self = self else { return }
            await self.fetchVersion()
            if self.isKmdEnabled {
                await self.fetchKmdBalance()
            }
        }
        // Create the repeating timer for periodic fetches at the specified interval
        timer = Timer.scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in
            Task { [weak self] in
                guard let self = self else { return }
                await self.fetchVersion()
                if self.isKmdEnabled {
                    await self.fetchKmdBalance()
                }
            }
        }
        // Start the countdown timer using the same interval
        startCountdown(interval: Int(interval))
    }

    /// Perform a JSON‑RPC call to the local mm2 HTTP endpoint to retrieve
    /// the version string.  This method is annotated as `@MainActor` to
    /// guarantee that `self.version` updates occur on the main thread.  If
    /// the request fails or returns an unexpected result the version is
    /// left unchanged.
    func fetchVersion() async {
        // Indicate that a fetch is in progress on the main actor
        await MainActor.run {
            self.isFetching = true
        }
        let url = URL(string: "http://127.0.0.1:7783")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        let body: [String: Any] = [
            "method": "version",
            "userpass": "use_safe_password"
        ]
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: body, options: [])
            appendAppLog("[RPC] version request: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "<invalid>")")
        } catch {
            appendAppLog("[RPC] version request serialization error: \(error)")
            return
        }
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            appendAppLog("[RPC] version response: \(String(data: data, encoding: .utf8) ?? "<invalid>")")
            guard
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                let result = json["result"] as? String
            else {
                appendAppLog("[RPC] version unexpected response")
                // Unexpected response means RPC may be down
                rpcUp = false
                return
            }
            // Update the published property on the main actor
            self.version = result
            // Mark RPC as up on successful response
            rpcUp = true
            // Increment fetch count
            fetchCount += 1
            // Reset the countdown to 10 seconds after a successful fetch
            secondsUntilNextFetch = 10
        } catch {
            appendAppLog("[RPC] version fetch error: \(error)")
            // On error, mark RPC as down
            rpcUp = false
        }
        // Regardless of success or failure, stop showing the loading spinner
        await MainActor.run {
            self.isFetching = false
        }
    }

    /// Manually trigger a version fetch.  This method simply delegates
    /// to `fetchVersion()` and is exposed for UI elements like a button.
    func manualFetch() {
        Task {
            await fetchVersion()
            if isKmdEnabled {
                await fetchKmdBalance()
            }
        }
    }

    /// Append a log message to the accumulated logs.  This helper ensures
    /// log updates occur on the main actor, as required by SwiftUI.
    private func appendLog(_ message: String) {
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            if self.logs.isEmpty {
                self.logs = message
            } else {
                self.logs += "\n" + message
            }
        }
    }

    /// Append a message to the application logs.  This helper
    /// maintains a separate log buffer for events generated by the
    /// Swift code (e.g. RPC requests and responses) so they can be
    /// viewed independently of the mm2 log output.
    private func appendAppLog(_ message: String) {
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            if self.appLogs.isEmpty {
                self.appLogs = message
            } else {
                self.appLogs += "\n" + message
            }
        }
    }

    /// Start the one‑second countdown timer that decrements
    /// `secondsUntilNextFetch`.  This resets the countdown to the
    /// fetch interval (10 seconds) and creates a repeating timer that
    /// updates the value every second.  The countdown timer is
    /// invalidated and recreated whenever the fetch timer is scheduled.
    /// Start the one-second countdown timer that decrements
    /// `secondsUntilNextFetch`.  The countdown is reset to the
    /// specified interval and decremented each second until it
    /// reaches 0, when it is reset to the same interval.  The
    /// countdown timer is invalidated and recreated whenever the
    /// fetch timer is rescheduled.
    private func startCountdown(interval: Int) {
        secondsUntilNextFetch = interval
        countdownTimer?.invalidate()
        countdownTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            if self.secondsUntilNextFetch > 0 {
                self.secondsUntilNextFetch -= 1
            } else {
                // Reset to the interval when reaching zero
                self.secondsUntilNextFetch = interval
            }
        }
    }

    //  KMD coin RPC methods

    /// Enable the KMD coin using the mm2 `enable` RPC method.  On
    /// success this sets `isKmdEnabled` to true and triggers an
    /// immediate balance fetch.  If the call fails the state
    /// remains unchanged and an error is printed to the console.
    func enableKmd() {
        Task {
            let url = URL(string: "http://127.0.0.1:7783")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            // Compose the Electrum activation request for KMD.
            let body: [String: Any] = [
                "method": "electrum",
                "coin": "KMD",
                "servers": [
                    ["url": "kmd.electrum3.cipig.net:10001", "protocol": "TCP"],
                    ["url": "kmd.electrum1.cipig.net:20001", "protocol": "SSL"],
                    ["url": "kmd.electrum3.cipig.net:20001", "protocol": "SSL"]
                ],
                // Use conservative confirmation and notarization settings as per
                // ca recommendations :)
                "required_confirmations": 10,
                "requires_notarization": true,
                "mm2": 1,
                "userpass": "use_safe_password"
            ]
            do {
                request.httpBody = try JSONSerialization.data(withJSONObject: body)
                appendAppLog("[RPC] enableKmd request: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "<invalid>")")
                let (data, _) = try await URLSession.shared.data(for: request)
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                appendAppLog("[RPC] enableKmd response: \(String(data: data, encoding: .utf8) ?? "<invalid>")")
                // Check for error in the response
                if let json = json {
                    if json["error"] != nil {
                        // Do not set enabled on error
                        appendAppLog("[RPC] enableKmd failed with error: \(json["error"]!)")
                        return
                    }
                }
                // If no error, mark the coin as enabled
                await MainActor.run {
                    self.isKmdEnabled = true
                }
                // Fetch the balance immediately after enabling
                await fetchKmdBalance()
            } catch {
                appendAppLog("[RPC] enableKmd caught exception: \(error)")
            }
        }
    }

    /// Disable the KMD coin using the mm2 `disable_coin` RPC method.  This
    /// call will mark `isKmdEnabled` as false on success and clear the
    /// stored balance/address.  If the call fails the state remains
    /// unchanged.
    func disableKmd() {
        Task {
            let url = URL(string: "http://127.0.0.1:7783")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            // The disable request must include a `coin` field to specify which
            // coin to disable.  The parameter is named `coin` not `ticker`.
            let body: [String: Any] = [
                "method": "disable_coin",
                "userpass": "use_safe_password",
                "coin": "KMD"
            ]
            do {
                request.httpBody = try JSONSerialization.data(withJSONObject: body)
                appendAppLog("[RPC] disableKmd request: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "<invalid>")")
                let (data, _) = try await URLSession.shared.data(for: request)
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                appendAppLog("[RPC] disableKmd response: \(String(data: data, encoding: .utf8) ?? "<invalid>")")
                // Check if an error field is present
                if let json = json, json["error"] != nil {
                    appendAppLog("[RPC] disableKmd failed with error: \(json["error"]!)")
                    return
                }
                await MainActor.run {
                    self.isKmdEnabled = false
                    self.kmdBalance = nil
                    self.kmdAddress = nil
                }
            } catch {
                appendAppLog("[RPC] disableKmd caught exception: \(error)")
            }
        }
    }

    /// Fetch the KMD balance and address using the mm2 `my_balance` RPC
    /// method.  On success this updates `kmdBalance` and `kmdAddress`.
    /// On failure it prints an error and does not modify existing
    /// values.  This method is called automatically every 10 seconds
    /// when the coin is enabled and can be triggered manually via the
    /// UI.
    func fetchKmdBalance() async {
        let url = URL(string: "http://127.0.0.1:7783")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        let body: [String: Any] = [
            "method": "my_balance",
            "userpass": "use_safe_password",
            "coin": "KMD"
        ]
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: body)
            appendAppLog("[RPC] my_balance request: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "<invalid>")")
            let (data, _) = try await URLSession.shared.data(for: request)
            appendAppLog("[RPC] my_balance response: \(String(data: data, encoding: .utf8) ?? "<invalid>")")
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                appendAppLog("[RPC] my_balance unexpected format")
                return
            }
            // mm2 may place the result fields at the root or under the
            // `result` key depending on version.  Attempt both.
            let resultDict: [String: Any]
            if let result = json["result"] as? [String: Any] {
                resultDict = result
            } else {
                resultDict = json
            }
            let address = resultDict["address"] as? String
            var balanceString: String?
            if let balance = resultDict["balance"] {
                // The `balance` field may be a dictionary or a number/string
                if let bal = balance as? [String: Any], let total = bal["total"] {
                    balanceString = String(describing: total)
                } else {
                    balanceString = String(describing: balance)
                }
            }
            await MainActor.run {
                var newBalance: String? = nil
                if let addr = address {
                    self.kmdAddress = addr
                }
                if let bal = balanceString {
                    // Determine if the balance has changed before updating
                    if self.kmdBalance != bal {
                        newBalance = bal
                    }
                    self.kmdBalance = bal
                }
                // Send a notification if a new balance was fetched
                if let balanceToNotify = newBalance {
                    self.sendBalanceNotification(balance: balanceToNotify)
                }
            }
        } catch {
            print("[KdfService] Error fetching KMD balance: \(error)")
        }
    }

    /// Manually fetch the KMD balance.  This simply invokes
    /// `fetchKmdBalance()` asynchronously if the coin is enabled.
    func manualBalanceFetch() {
        guard isKmdEnabled else { return }
        Task {
            await fetchKmdBalance()
        }
    }

    /// Copy the current KMD address to the system clipboard.  This
    /// operation is only available on platforms where `UIPasteboard`
    /// exists (iOS).  If the address is nil or UIKit is unavailable
    /// this method does nothing.
    func copyKmdAddressToClipboard() {
        guard let address = kmdAddress else { return }
        #if canImport(UIKit)
        UIPasteboard.general.string = address
        #endif
    }

#if canImport(UIKit)
    /// Begin a background task to keep timers running when the app moves
    /// to the background.  Call this when the scene phase transitions to
    /// `.background` and call `endBackgroundTask()` when returning to
    /// foreground or stopping the service.
    func beginBackgroundTask() {
        if backgroundTask == .invalid {
            backgroundTask = UIApplication.shared.beginBackgroundTask(withName: "KdfServiceBackgroundTask") { [weak self] in
                // Expiration handler: end the task when the system requires
                if let bt = self?.backgroundTask {
                    UIApplication.shared.endBackgroundTask(bt)
                    self?.backgroundTask = .invalid
                }
            }
        }
    }

    /// End the active background task if any.  Safe to call multiple times.
    func endBackgroundTask() {
        if backgroundTask != .invalid {
            UIApplication.shared.endBackgroundTask(backgroundTask)
            backgroundTask = .invalid
        }
    }
#else
    /// On non‑iOS platforms these methods are no‑ops.
    func beginBackgroundTask() {}
    func endBackgroundTask() {}
#endif

    /// Schedule a local notification indicating that the KMD balance
    /// has been updated.  Notifications are only supported on iOS and
    /// will be ignored on other platforms.  The notification will
    /// appear immediately.  If the app is active the notification
    /// centre may suppress the alert depending on user settings.
    private func sendBalanceNotification(balance: String) {
        #if canImport(UserNotifications) && canImport(UIKit)
        let content = UNMutableNotificationContent()
        content.title = "KMD Balance Updated"
        content.body = "New balance: \(balance)"
        content.sound = .default
        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: nil)
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("[KdfService] Failed to schedule notification: \(error)")
            }
        }
        #endif
    }

    //  Interval management

    /// Update the fetch interval for the version (and balance) timers.
    /// This method reschedules the timers with the new interval if
    /// mm2 has already started.  If mm2 is not yet started the
    /// interval is simply stored and will be used when the timers are
    /// scheduled.
    func updateFetchInterval(to newInterval: Double) {
        // Store the desired interval
        currentInterval = newInterval
        // If the timer is already scheduled, reschedule it with the new interval
        if timer != nil {
            scheduleVersionTimer(withInterval: currentInterval)
        }
    }
}
